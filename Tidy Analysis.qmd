---
title: "Tidy Analysis"
author: "Eric Mossotti"

code-fold: true

df_print: "tibble" 

format: html
toc: true
---

```{r include= FALSE}

knitr::opts_chunk$set(message = FALSE, warning = FALSE)

```

```{r}
libs <- c("duckdb", 
          "arrow", 
          "curl", 
          "tidyverse")

lapply ( libs, 
         library, 
         character.only = TRUE ) |>
    
    invisible ()
```

# Data Importing

```{r}

durls <- sprintf ( 
    "https://divvy-tripdata.s3.amazonaws.com/%d-divvy-tripdata.zip",
    202301:202312 )

zipPaths <- sprintf ( "tripZips/%d-divvy-tripdata.zip",
                      202301:202312 )

filePaths <- sprintf ( "tripdata/%d-divvy-tripdata.csv",
                       202301:202312 )

zipNames <- sprintf ( "%d-divvy-tripdata.zip",
                      202301:202312 )

fileNames <- sprintf ( "%d-divvy-tripdata.csv",
                       202301:202312)


pq_path <- "pq_tripdata"


dir.create ( "tripZips" )

dir.create ( "tripdata" )

dir.create ( "pq_tripdata" )



# multi_download {curl}	
multi_download ( durls, 
                 destfiles = zipPaths )


unz_csv <- function ( x = filePaths, 
                      y = zipPaths, 
                      z = fileNames ) {
    
    for ( i in seq(x) ) {

        unzip ( y[i],
                z[i] )
        
        file.rename ( z[i],
                      x[i] )
    }
}
```

```{r}

# list.files {base}
csvFileList <- list.files ( path = "tripdata", 
                            full.names = TRUE )

# view {tibble} 
matrix ( csvFileList, 
         dimnames = list ( seq ( csvFileList ), 
                           c ( "csvfiles" ) 
                           ) 
         )
```

```{r}

# map {purrr}, 

# With list_rbind(), map can be used to directly create a dataframe from a list of files
oneTibble <- map ( csvFileList[1:12], read_csv ) |>
    
    list_rbind  ()
```

( In R a tibble is synonymous with a data frame )

```{r}

typeof ( oneTibble )

is_tibble ( oneTibble )

is.data.frame ( oneTibble )
```

```{r}
oneTibble[1,]
```

```{r}
originalLength <- length ( oneTibble[[1]] )

print(originalLength)
```

```{r}

# drop_na {tidyr}	
oneTibble <- drop_na ( oneTibble )
```

```{r}
tibble ( Complete_Observations = 
             length ( oneTibble [[1]] ),
         "Rows Deleted" = Complete_Observations - originalLength )
```

```{r}



# Maybe only need to check ride_id column? Actually, no.

# pick {dplyr}	
distinct ( oneTibble, pick ( "ride_id" ) ) |>
    
    # count {dplyr}	
    count ( name = "Distinct Ride ID's" )
```

```{r}

# This is a separate table used to analyze the observations returned as not distinct (n > 1). This adds an extra column (n) so didn't want to mess with the main dataframe for this.

dupTibble <- oneTibble |>
    
    # adds a count of rows for column 'n'
    add_count ( started_at, 
                ended_at, 
                start_station_name, 
                end_station_name ) |>
    
    # so that only observations that have been duplicated 1 or more         times are shown
    filter ( n > 1 ) |>
    
    # will have to retest if I need this function
    distinct ( ) |>
    
    # because we want to see all the rows, not just one row for each obs
    ungroup ( ) |>
    
    arrange ( started_at )
```

```{r}

print ( dupTibble[3:4] )
```

```{r}

# verify how many rows have/are duplicates
 
# nrow {base}
nrow ( dupTibble )
```

```{r}

# issue is, we need to get rid of not all of these rows, but just the extra duplicate observations. 

# If there were 2 rows of duplicates, we would want to end up with 1 row after removing the extras.

undupdTibble <- dupTibble |>
    
    # distinct {dplyr}
    distinct ( started_at, 
               start_station_name, 
               ended_at, 
               end_station_name, 
               .keep_all = TRUE )
```

```{r}

print ( undupdTibble[3:4] )
```

```{r}

nrow ( undupdTibble )
```

```{r}

distinct ( oneTibble, pick ( "ride_id" ) ) |>
    
    # count {dplyr}	
    count ( name = "Uncorrected Distinct Observations" )
```

```{r}

distinct ( oneTibble, pick ( "started_at",
                             "start_station_name",
                             "ended_at", 
                             "end_station_name" ) ) |>
    # count {dplyr}	
    count ( name = "Corrected Distinct Observations" )
```

```{r}

oneTibble <- oneTibble |>
    
    distinct ( started_at, 
               start_station_name, 
               ended_at, 
               end_station_name, 
               .keep_all = TRUE )
```

```{r}
count ( oneTibble,
        name =
            "Total Observations: Un-duplicated Dataset" )
```

```{r}
oneTibble[3] |>
    
    # arrange {dplyr}	
    arrange ( started_at ) |>
    
    head ()
```

```{r}
# sorting the entire table by the start_at column
oneTibble <- oneTibble |>
    # arrange {dplyr}
    arrange ( started_at )
```

```{r}
print(head(oneTibble[3:4]))
```

```{r}

# Split cells
oneTibble[3] |>
    
    # separate_wider_delim {tidyr}
    separate_wider_delim ( cols = c(started_at),
                           delim = " ",
                           names = c("start_date", 
                                    "start_time"),
                           cols_remove = TRUE) |>
    head()
```

```{r}
# Split cells
oneTibble[3] |>
    
    # separate_wider_delim {tidyr}
    separate_wider_delim ( cols = c(started_at),
                           delim = " ",
                           names = c("start_date", 
                                    "start_time"),
                           cols_remove = TRUE ) |>
    head ()
```

```{r}

oneTibble[4] |>
    
    separate_wider_delim ( cols = c(ended_at),
                           delim = " ",
                           names = c("end_date", 
                                    "end_time"),
                           cols_remove = TRUE ) |>
    
    head()
```

```{r}
# Split cells
oneTibble <- oneTibble |>
    
    # separate_wider_delim {tidyr}
    separate_wider_delim ( cols = c ( started_at ),
                           delim = " ",
                           names = c ( "start_date",
                                       "start_time" ),
                           cols_remove = TRUE )
```

```{r}
tibble_row ( "How many columns?" = ncol ( oneTibble ) )
```

```{r}

oneTibble <- oneTibble |>
    
    separate_wider_delim ( cols = c(ended_at),
                           delim = " ",
                           names = c("end_date", 
                                    "end_time"),
                           cols_remove = TRUE )
```

```{r}
tibble_row ( "How many columns?" = ncol ( oneTibble ) )
```

Â 

```{r}

head ( oneTibble )
```

```{r}

oneTibble2 <- oneTibble |>
    
    group_by ( rideable_type ) |>
    
    # nest {tidyr}
    nest ()
```

## Arrow and DuckDB

[R for Data Science: Chapter 22: Arrow](https://r4ds.hadley.nz/arrow "Arrow")

```{r}
# open_dataset {arrow}	
trip_dataset <- open_dataset ( "tripdata", 
                               format = "csv" )

trip_dataset |>
    
    # write_dataset {arrow}	
    write_dataset ( path = pq_path, 
                    format = "parquet" )

trip_dataset_pq <- open_dataset ( pq_path )

# methods_overwrite {duckplyr}	
#methods_overwrite()

#methods_restore()

trip_dataset_pq |>
    
    to_duckdb () |>
    
    distinct ( pick ( ride_id ) ) |>
    
    count ( name = "Distinct Ride ID's" )

# dbConnect {DBI}
duckCon <- dbConnect ( duckdb ( ) )

duckdb_register_arrow ( duckCon, 
                        "tripdb_wArrow", 
                        trip_dataset_pq )

tbl ( duckCon, 
      
    "tripdb_wArrow" ) |>
    
    distinct ( pick ( ride_id ) ) |>
    
    count ( name = "Distinct" )
```
